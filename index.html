<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Space Shooter</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: sans-serif;
            overflow: hidden;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }
        .stat {
            font-size: 24px;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }
        .btn {
            padding: 12px 24px;
            font-size: 18px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
        }
        /* 視点中央の照準 */
        #reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 20;
        }
        /* VRエントリーボタンのスタイル */
        #vr-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border: 1px solid #fff;
            border-radius: 4px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            font: bold 14px sans-serif;
            text-align: center;
            z-index: 999;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Time: <span id="time">60</span>s</div>
    </div>
    <div id="reticle"></div>
    <div id="msg">
        <h1>WebXR Shooter (Auto-Fire)</h1>
        <p>視点をターゲットに合わせると自動で発射します！</p>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, score = 0, timeLeft = 60;
        let targets = [];
        let bullets = [];
        let isGameRunning = false;
        let lastFireTime = 0;
        const fireRate = 300; // 発射間隔 (ms)

        let vrUI; // VR用UIグループ
        let scoreTextCanvas, timeTextCanvas;

        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');
        const msgElement = document.getElementById('msg');
        const raycaster = new THREE.Raycaster();

        // VRButtonの代替機能を実装
        function createVRButton(renderer) {
            const button = document.createElement('button');
            button.id = 'vr-button';
            button.textContent = 'WEBXR LOADING...';

            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
                    if (supported) {
                        button.textContent = 'ENTER VR';
                        button.onclick = () => {
                            if (currentSession === null) {
                                navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor'] }).then(onSessionStarted);
                            } else {
                                currentSession.end();
                            }
                        };
                    } else {
                        button.textContent = 'VR NOT SUPPORTED';
                    }
                });
            } else {
                button.textContent = 'WEBXR NOT AVAILABLE';
            }

            let currentSession = null;
            function onSessionStarted(session) {
                session.addEventListener('end', onSessionEnded);
                renderer.xr.setSession(session);
                button.textContent = 'EXIT VR';
                currentSession = session;
                if(vrUI) vrUI.visible = true;
            }
            function onSessionEnded() {
                currentSession.removeEventListener('end', onSessionEnded);
                button.textContent = 'ENTER VR';
                currentSession = null;
                if(vrUI) vrUI.visible = false;
            }

            return button;
        }

        window.onload = function() {
            init();
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            scene.fog = new THREE.Fog(0x111122, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            const cameraGroup = new THREE.Group();
            scene.add(cameraGroup);
            cameraGroup.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            document.body.appendChild(createVRButton(renderer));

            // ライティング
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            // 床
            const grid = new THREE.GridHelper(100, 40, 0x00ff00, 0x444444);
            scene.add(grid);

            // VR内UIの作成
            createVRUI(camera);

            window.addEventListener('resize', onWindowResize, false);

            renderer.setAnimationLoop(render);
            startGame();
        }

        // VR空間用のUIパネル作成
        function createVRUI(parent) {
            vrUI = new THREE.Group();
            vrUI.position.set(0, 0, -1.5); // カメラの少し前に配置
            vrUI.visible = false; // VRセッション開始まで非表示
            parent.add(vrUI);

            scoreTextCanvas = createTextCanvas('Score: 0');
            const scorePlane = new THREE.Mesh(
                new THREE.PlaneGeometry(0.5, 0.15),
                new THREE.MeshBasicMaterial({ map: scoreTextCanvas.texture, transparent: true })
            );
            scorePlane.position.set(-0.4, 0.3, 0);
            vrUI.add(scorePlane);

            timeTextCanvas = createTextCanvas('Time: 60s');
            const timePlane = new THREE.Mesh(
                new THREE.PlaneGeometry(0.5, 0.15),
                new THREE.MeshBasicMaterial({ map: timeTextCanvas.texture, transparent: true })
            );
            timePlane.position.set(0.4, 0.3, 0);
            vrUI.add(timePlane);

            // VR用レティクル（3D空間の照準）
            const reticleGeo = new THREE.RingGeometry(0.015, 0.02, 32);
            const reticleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const vrReticle = new THREE.Mesh(reticleGeo, reticleMat);
            vrReticle.position.set(0, 0, -1);
            vrUI.add(vrReticle);
        }

        function createTextCanvas(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            function update(newText) {
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'rgba(0,0,0,0.5)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.font = 'Bold 40px sans-serif';
                context.fillStyle = '#ffffff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(newText, canvas.width / 2, canvas.height / 2);
                texture.needsUpdate = true;
            }

            const texture = new THREE.CanvasTexture(canvas);
            update(text);
            return { texture, update };
        }

        function startGame() {
            isGameRunning = true;
            score = 0;
            timeLeft = 60;
            updateUIScore();
            updateUITime();
            msgElement.style.display = 'none';

            const spawnInterval = setInterval(() => {
                if (!isGameRunning) {
                    clearInterval(spawnInterval);
                    return;
                }
                spawnTarget();
            }, 1000);

            const timerInterval = setInterval(() => {
                timeLeft--;
                updateUITime();
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }

        function updateUIScore() {
            scoreElement.innerText = score;
            if(scoreTextCanvas) scoreTextCanvas.update('Score: ' + score);
        }

        function updateUITime() {
            timeElement.innerText = timeLeft;
            if(timeTextCanvas) timeTextCanvas.update('Time: ' + timeLeft + 's');
        }

        function spawnTarget() {
            const geometry = new THREE.IcosahedronGeometry(0.3, 0);
            const material = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff,
                emissive: 0x222222
            });
            const target = new THREE.Mesh(geometry, material);

            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 5;
            target.position.set(
                Math.cos(angle) * radius,
                1 + Math.random() * 2,
                Math.sin(angle) * radius
            );

            scene.add(target);
            targets.push(target);
        }

        function shoot(position, direction) {
            if (!isGameRunning) return;

            const now = Date.now();
            if (now - lastFireTime < fireRate) return;
            lastFireTime = now;

            const geo = new THREE.SphereGeometry(0.05, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(geo, mat);
            
            bullet.position.copy(position);
            // 進行方向ベクトルを正規化してから速度を掛ける
            const velocity = direction.clone().normalize().multiplyScalar(0.4);
            bullet.userData.velocity = velocity;
            bullet.userData.life = 100;

            scene.add(bullet);
            bullets.push(bullet);
        }

        function endGame() {
            isGameRunning = false;
            msgElement.style.display = 'block';
            msgElement.innerHTML = `<h1>Time Up!</h1><p>Final Score: ${score}</p><button class="btn" onclick="location.reload()">Retry</button>`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function render() {
            if (isGameRunning) {
                // VRカメラのワールド座標と向きを正しく取得
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.extractRotation(camera.matrixWorld);
                const direction = new THREE.Vector3(0, 0, -1).applyMatrix4(tempMatrix);
                
                const position = new THREE.Vector3();
                camera.getWorldPosition(position);

                raycaster.set(position, direction);
                const intersects = raycaster.intersectObjects(targets);

                if (intersects.length > 0) {
                    shoot(position, direction);
                }
            }

            targets.forEach((target) => {
                target.rotation.y += 0.02;
            });

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.add(b.userData.velocity);
                b.userData.life--;

                for (let j = targets.length - 1; j >= 0; j--) {
                    const t = targets[j];
                    if (b.position.distanceTo(t.position) < 0.5) {
                        scene.remove(t);
                        targets.splice(j, 1);
                        scene.remove(b);
                        bullets.splice(i, 1);
                        score += 10;
                        updateUIScore();
                        break;
                    }
                }

                if (b && b.userData.life <= 0) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
